{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Primitives \u00b6 Fake objects designed with OOP in mind. Documentation | Source Code | Task Tracker Mock objects makes your tests worst. Usage of mock objects is considered an anti-pattern by many experienced developers. Mock objects blindly respond to any interaction. Patch function is able to put such objects in any place in your code. It does not matter if that code was written in a way to be configured or not. This situation has several consequences. First of all, your tests start making assumptions about implementation of tested code. This creates high coupling between tests and code. You no more could easily change your code because 25 tests are aware of the name of the function in the middle of the call stack. The second unpleasant details about mocks is its fragile blind trust to the client code. Writing mocks of proper quality is extremely complicated. You need a ton of assert statements at the end of the test to check that only expected methods were called. In addition API of the mock library in python is an ugly procedural code. It requires a 3 lines just to define a dumb method returning predefined value on mock. This harms readability of tests dramatically. I was upset with mock library for the long time. I decided to design a collection of strict composable objects without ability to put them at random place in code. Here is what I came with! Pros \u00b6 Fake objects with strict behavior will highlight problems in your code earlier Nice composable API makes definition of complex objects short and concrete Force user to use composition instead of patch Example \u00b6 The primitives library gives you a collection of objects with ability to define expected behavior as set of short expressions. For example, you could define a function returning None like this: >>> from primitives import Callable >>> func = Callable () >>> func () Questions \u00b6 If you have any questions, feel free to create an issue in our Task Tracker . We have the question label exactly for this purpose. Enterprise support \u00b6 If you have an issue with any version of the library, you can apply for a paid enterprise support contract. This will guarantee you that no breaking changes will happen to you. No matter how old version you're using at the moment. All necessary features and bug fixes will be backported in a way that serves your needs. Please contact proofit404@gmail.com if you're interested in it. License \u00b6 primitives library is offered under the two clause BSD license. \u2014 \u2b50\ufe0f \u2014 The `primitives` library is part of the SOLID python family.","title":"Home"},{"location":"#primitives","text":"Fake objects designed with OOP in mind. Documentation | Source Code | Task Tracker Mock objects makes your tests worst. Usage of mock objects is considered an anti-pattern by many experienced developers. Mock objects blindly respond to any interaction. Patch function is able to put such objects in any place in your code. It does not matter if that code was written in a way to be configured or not. This situation has several consequences. First of all, your tests start making assumptions about implementation of tested code. This creates high coupling between tests and code. You no more could easily change your code because 25 tests are aware of the name of the function in the middle of the call stack. The second unpleasant details about mocks is its fragile blind trust to the client code. Writing mocks of proper quality is extremely complicated. You need a ton of assert statements at the end of the test to check that only expected methods were called. In addition API of the mock library in python is an ugly procedural code. It requires a 3 lines just to define a dumb method returning predefined value on mock. This harms readability of tests dramatically. I was upset with mock library for the long time. I decided to design a collection of strict composable objects without ability to put them at random place in code. Here is what I came with!","title":"Primitives"},{"location":"#pros","text":"Fake objects with strict behavior will highlight problems in your code earlier Nice composable API makes definition of complex objects short and concrete Force user to use composition instead of patch","title":"Pros"},{"location":"#example","text":"The primitives library gives you a collection of objects with ability to define expected behavior as set of short expressions. For example, you could define a function returning None like this: >>> from primitives import Callable >>> func = Callable () >>> func ()","title":"Example"},{"location":"#questions","text":"If you have any questions, feel free to create an issue in our Task Tracker . We have the question label exactly for this purpose.","title":"Questions"},{"location":"#enterprise-support","text":"If you have an issue with any version of the library, you can apply for a paid enterprise support contract. This will guarantee you that no breaking changes will happen to you. No matter how old version you're using at the moment. All necessary features and bug fixes will be backported in a way that serves your needs. Please contact proofit404@gmail.com if you're interested in it.","title":"Enterprise support"},{"location":"#license","text":"primitives library is offered under the two clause BSD license. \u2014 \u2b50\ufe0f \u2014 The `primitives` library is part of the SOLID python family.","title":"License"},{"location":"callable/","text":"Callable \u00b6 Callable fake object is an easy way to reproduce behavior of a function or a method. An empty Callable object will just return null value. >>> from primitives import Callable >>> func = Callable () >>> func () A return value passed to Callable constructor will be returned as is when you'll call the object. >>> func = Callable ( 1 ) >>> func () 1 Only one return value could be passed to the Callable object at the initialization. >>> Callable ( 1 , 2 ) Traceback (most recent call last): ... _primitives.exceptions.PrimitiveError : 'Callable' object should have only one return value To make your fake object be able to accept positional arguments, you can pass Argument object at the initialization. An Argument object should have allowed value for this argument to call. >>> from primitives import Argument >>> func = Callable ( 1 , Argument ( 'a' )) >>> func ( 'a' ) 1 >>> func ( 'b' ) Traceback (most recent call last): ... _primitives.exceptions.PrimitiveError : Called with argument 'b' while expected 'a' If you want your callable fake object to receive arguments but return null, you can avoid specifying return value explicitly. >>> func = Callable ( Argument ( 'a' ), Argument ( 'b' )) >>> func ( 'a' , 'b' ) A Callable fake object would as well check if amount of passed arguments matched arity of declared function. >>> func ( 'a' ) Traceback (most recent call last): ... _primitives.exceptions.PrimitiveError : Called with less arguments than expected >>> func ( 'a' , 'b' , 'c' ) Traceback (most recent call last): ... _primitives.exceptions.PrimitiveError : Called with more arguments than expected","title":"Callable"},{"location":"callable/#callable","text":"Callable fake object is an easy way to reproduce behavior of a function or a method. An empty Callable object will just return null value. >>> from primitives import Callable >>> func = Callable () >>> func () A return value passed to Callable constructor will be returned as is when you'll call the object. >>> func = Callable ( 1 ) >>> func () 1 Only one return value could be passed to the Callable object at the initialization. >>> Callable ( 1 , 2 ) Traceback (most recent call last): ... _primitives.exceptions.PrimitiveError : 'Callable' object should have only one return value To make your fake object be able to accept positional arguments, you can pass Argument object at the initialization. An Argument object should have allowed value for this argument to call. >>> from primitives import Argument >>> func = Callable ( 1 , Argument ( 'a' )) >>> func ( 'a' ) 1 >>> func ( 'b' ) Traceback (most recent call last): ... _primitives.exceptions.PrimitiveError : Called with argument 'b' while expected 'a' If you want your callable fake object to receive arguments but return null, you can avoid specifying return value explicitly. >>> func = Callable ( Argument ( 'a' ), Argument ( 'b' )) >>> func ( 'a' , 'b' ) A Callable fake object would as well check if amount of passed arguments matched arity of declared function. >>> func ( 'a' ) Traceback (most recent call last): ... _primitives.exceptions.PrimitiveError : Called with less arguments than expected >>> func ( 'a' , 'b' , 'c' ) Traceback (most recent call last): ... _primitives.exceptions.PrimitiveError : Called with more arguments than expected","title":"Callable"},{"location":"changelog/","text":"1.2.0 (2021-01-03) \u00b6 Features \u00b6 implement callable positional argument #4 ( 60b349b ) 1.1.0 (2021-01-02) \u00b6 Features \u00b6 implement callable return value #3 ( 4294426 ) 1.0.0 (2020-12-26) \u00b6 Features \u00b6 empty Callable object #2 ( 8003419 ) \u2014 \u2b50\ufe0f \u2014 The `primitives` library is part of the SOLID python family.","title":"Changelog"},{"location":"changelog/#120-2021-01-03","text":"","title":"1.2.0 (2021-01-03)"},{"location":"changelog/#features","text":"implement callable positional argument #4 ( 60b349b )","title":"Features"},{"location":"changelog/#110-2021-01-02","text":"","title":"1.1.0 (2021-01-02)"},{"location":"changelog/#features_1","text":"implement callable return value #3 ( 4294426 )","title":"Features"},{"location":"changelog/#100-2020-12-26","text":"","title":"1.0.0 (2020-12-26)"},{"location":"changelog/#features_2","text":"empty Callable object #2 ( 8003419 ) \u2014 \u2b50\ufe0f \u2014 The `primitives` library is part of the SOLID python family.","title":"Features"},{"location":"installation/","text":"Installation \u00b6 The primitives library is available on PyPI. To install it run: pip install -U primitives We use semantic release to publish packages as soon as pull requests land to the master branch. It's not necessary to use develompment version of the library. We officially support three last minor releases of CPython interpreter and last minor release of PyPy interpreter. We highly recommend the latest patch release of each Python series. \u2014 \u2b50\ufe0f \u2014 The `primitives` library is part of the SOLID python family.","title":"Installation"},{"location":"installation/#installation","text":"The primitives library is available on PyPI. To install it run: pip install -U primitives We use semantic release to publish packages as soon as pull requests land to the master branch. It's not necessary to use develompment version of the library. We officially support three last minor releases of CPython interpreter and last minor release of PyPy interpreter. We highly recommend the latest patch release of each Python series. \u2014 \u2b50\ufe0f \u2014 The `primitives` library is part of the SOLID python family.","title":"Installation"}]}