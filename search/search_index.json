{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Primitives \u00b6 Fake objects designed with OOP in mind. Documentation | Source Code | Task Tracker Mock objects makes your tests worst. Usage of mock objects is considered an anti-pattern by many experienced developers. Mock objects blindly respond to any interaction. Patch function is able to put such objects in any place in your code. It does not matter if that code was written in a way to be configured or not. This situation has several consequences. First of all, your tests start making assumptions about implementation of tested code. This creates high coupling between tests and code. You no more could easily change your code because 25 tests are aware of the name of the function in the middle of the call stack. The second unpleasant details about mocks is its fragile blind trust to the client code. Writing mocks of proper quality is extremely complicated. You need a ton of assert statements at the end of the test to check that only expected methods were called. In addition API of the mock library in python is an ugly procedural code. It requires a 3 lines just to define a dumb method returning predefined value on mock. This harms readability of tests dramatically. I was upset with mock library for the long time. I decided to design a collection of strict composable objects without ability to put them at random place in code. Here is what I came with! Pros \u00b6 Fake objects with strict behavior will highlight problems in your code earlier Nice composable API makes definition of complex objects short and concrete Force user to use composition instead of patch Example \u00b6 The primitives library gives you a collection of objects with ability to define expected behavior as set of short expressions. For example, you could define a function returning None like this: >>> from primitives import Instance , Callable , Argument >>> func = Callable () >>> func () Let's try to test a function below using primitives fake objects and standard unittest.mock library for comparison. >>> def greet_many ( repo ): ... for user in repo . users (): ... print ( user . greet ( 'Hello' )) >>> greet_many ( Instance ( users = Callable ([ ... Instance ( greet = Callable ( 'Hello, John' , Argument ( 'Hello' ))), ... Instance ( greet = Callable ( 'Hello, Kate' , Argument ( 'Hello' ))), ... ]))) Hello, John Hello, Kate We would leave unittest.mock implementation to the reader as a homework. Questions \u00b6 If you have any questions, feel free to create an issue in our Task Tracker . We have the question label exactly for this purpose. Enterprise support \u00b6 If you have an issue with any version of the library, you can apply for a paid enterprise support contract. This will guarantee you that no breaking changes will happen to you. No matter how old version you're using at the moment. All necessary features and bug fixes will be backported in a way that serves your needs. Please contact proofit404@gmail.com if you're interested in it. License \u00b6 primitives library is offered under the two clause BSD license. \u2014 \u2b50 \u2014 The primitives library is part of the SOLID python family.","title":"Home"},{"location":"#primitives","text":"Fake objects designed with OOP in mind. Documentation | Source Code | Task Tracker Mock objects makes your tests worst. Usage of mock objects is considered an anti-pattern by many experienced developers. Mock objects blindly respond to any interaction. Patch function is able to put such objects in any place in your code. It does not matter if that code was written in a way to be configured or not. This situation has several consequences. First of all, your tests start making assumptions about implementation of tested code. This creates high coupling between tests and code. You no more could easily change your code because 25 tests are aware of the name of the function in the middle of the call stack. The second unpleasant details about mocks is its fragile blind trust to the client code. Writing mocks of proper quality is extremely complicated. You need a ton of assert statements at the end of the test to check that only expected methods were called. In addition API of the mock library in python is an ugly procedural code. It requires a 3 lines just to define a dumb method returning predefined value on mock. This harms readability of tests dramatically. I was upset with mock library for the long time. I decided to design a collection of strict composable objects without ability to put them at random place in code. Here is what I came with!","title":"Primitives"},{"location":"#pros","text":"Fake objects with strict behavior will highlight problems in your code earlier Nice composable API makes definition of complex objects short and concrete Force user to use composition instead of patch","title":"Pros"},{"location":"#example","text":"The primitives library gives you a collection of objects with ability to define expected behavior as set of short expressions. For example, you could define a function returning None like this: >>> from primitives import Instance , Callable , Argument >>> func = Callable () >>> func () Let's try to test a function below using primitives fake objects and standard unittest.mock library for comparison. >>> def greet_many ( repo ): ... for user in repo . users (): ... print ( user . greet ( 'Hello' )) >>> greet_many ( Instance ( users = Callable ([ ... Instance ( greet = Callable ( 'Hello, John' , Argument ( 'Hello' ))), ... Instance ( greet = Callable ( 'Hello, Kate' , Argument ( 'Hello' ))), ... ]))) Hello, John Hello, Kate We would leave unittest.mock implementation to the reader as a homework.","title":"Example"},{"location":"#questions","text":"If you have any questions, feel free to create an issue in our Task Tracker . We have the question label exactly for this purpose.","title":"Questions"},{"location":"#enterprise-support","text":"If you have an issue with any version of the library, you can apply for a paid enterprise support contract. This will guarantee you that no breaking changes will happen to you. No matter how old version you're using at the moment. All necessary features and bug fixes will be backported in a way that serves your needs. Please contact proofit404@gmail.com if you're interested in it.","title":"Enterprise support"},{"location":"#license","text":"primitives library is offered under the two clause BSD license. \u2014 \u2b50 \u2014 The primitives library is part of the SOLID python family.","title":"License"},{"location":"async_context/","text":"AsyncContext \u00b6 Principles \u00b6 Empty AsyncContext object returns none Value passed to AsyncContext object would be returned AsyncContext object could be returned by Callable object Empty AsyncContext object returns none \u00b6 >>> import asyncio >>> from primitives import AsyncContext >>> async def check (): ... async with resourse as result : ... return result >>> resourse = AsyncContext () >>> asyncio . run ( check ()) Value passed to AsyncContext object would be returned \u00b6 >>> async def check (): ... async with resourse as result : ... return result >>> resourse = AsyncContext ( 1 ) >>> asyncio . run ( check ()) 1 AsyncContext object could be returned by Callable object \u00b6 >>> from primitives import Callable , Argument >>> async def check (): ... async with resourse ( 'John' ) as result : ... return result >>> resourse = Callable ( AsyncContext ( 1 ), Argument ( 'John' )) >>> asyncio . run ( check ()) 1 \u2014 \u2b50 \u2014 The primitives library is part of the SOLID python family.","title":"AsyncContext"},{"location":"async_context/#asynccontext","text":"","title":"AsyncContext"},{"location":"async_context/#principles","text":"Empty AsyncContext object returns none Value passed to AsyncContext object would be returned AsyncContext object could be returned by Callable object","title":"Principles"},{"location":"async_context/#empty-asynccontext-object-returns-none","text":">>> import asyncio >>> from primitives import AsyncContext >>> async def check (): ... async with resourse as result : ... return result >>> resourse = AsyncContext () >>> asyncio . run ( check ())","title":"Empty AsyncContext object returns none"},{"location":"async_context/#value-passed-to-asynccontext-object-would-be-returned","text":">>> async def check (): ... async with resourse as result : ... return result >>> resourse = AsyncContext ( 1 ) >>> asyncio . run ( check ()) 1","title":"Value passed to AsyncContext object would be returned"},{"location":"async_context/#asynccontext-object-could-be-returned-by-callable-object","text":">>> from primitives import Callable , Argument >>> async def check (): ... async with resourse ( 'John' ) as result : ... return result >>> resourse = Callable ( AsyncContext ( 1 ), Argument ( 'John' )) >>> asyncio . run ( check ()) 1 \u2014 \u2b50 \u2014 The primitives library is part of the SOLID python family.","title":"AsyncContext object could be returned by Callable object"},{"location":"awaitable/","text":"Awaitable \u00b6 Principles \u00b6 Empty Awaitable object returns none Value passed to Awaitable object would be returned Awaitable object could be returned by Callable object Empty Awaitable object returns none \u00b6 >>> import asyncio >>> from primitives import Awaitable >>> awaitable = Awaitable () >>> async def check (): ... return await awaitable >>> asyncio . run ( check ()) Value passed to Awaitable object would be returned \u00b6 >>> awaitable = Awaitable ( 1 ) >>> asyncio . run ( check ()) 1 Awaitable object could be returned by Callable object \u00b6 >>> from primitives import Callable >>> coro = Callable ( Awaitable ( 1 )) >>> async def check (): ... return await coro () >>> asyncio . run ( check ()) 1 \u2014 \u2b50 \u2014 The primitives library is part of the SOLID python family.","title":"Awaitable"},{"location":"awaitable/#awaitable","text":"","title":"Awaitable"},{"location":"awaitable/#principles","text":"Empty Awaitable object returns none Value passed to Awaitable object would be returned Awaitable object could be returned by Callable object","title":"Principles"},{"location":"awaitable/#empty-awaitable-object-returns-none","text":">>> import asyncio >>> from primitives import Awaitable >>> awaitable = Awaitable () >>> async def check (): ... return await awaitable >>> asyncio . run ( check ())","title":"Empty Awaitable object returns none"},{"location":"awaitable/#value-passed-to-awaitable-object-would-be-returned","text":">>> awaitable = Awaitable ( 1 ) >>> asyncio . run ( check ()) 1","title":"Value passed to Awaitable object would be returned"},{"location":"awaitable/#awaitable-object-could-be-returned-by-callable-object","text":">>> from primitives import Callable >>> coro = Callable ( Awaitable ( 1 )) >>> async def check (): ... return await coro () >>> asyncio . run ( check ()) 1 \u2014 \u2b50 \u2014 The primitives library is part of the SOLID python family.","title":"Awaitable object could be returned by Callable object"},{"location":"callable/","text":"Callable \u00b6 Callable fake object is an easy way to reproduce behavior of a function or a method. An empty Callable object will just return null value. >>> from primitives import Callable >>> func = Callable () >>> func () A return value passed to Callable constructor will be returned as is when you'll call the object. >>> func = Callable ( 1 ) >>> func () 1 Only one return value could be passed to the Callable object at the initialization. >>> Callable ( 1 , 2 ) Traceback (most recent call last): ... _primitives.exceptions.PrimitiveError : 'Callable' object should have only one return value To make your fake object be able to accept positional arguments, you can pass Argument object at the initialization. An Argument object should have allowed value for this argument to call. >>> from primitives import Argument >>> func = Callable ( 1 , Argument ( 'a' )) >>> func ( 'a' ) 1 >>> func ( 'b' ) Traceback (most recent call last): ... _primitives.exceptions.PrimitiveError : Called with argument 'b' while expected 'a' If you want your callable fake object to receive arguments but return null, you can avoid specifying return value explicitly. >>> func = Callable ( Argument ( 'a' ), Argument ( 'b' )) >>> func ( 'a' , 'b' ) A Callable fake object would as well check if amount of passed arguments matched arity of declared function. >>> func ( 'a' ) Traceback (most recent call last): ... _primitives.exceptions.PrimitiveError : Called with less arguments than expected >>> func ( 'a' , 'b' , 'c' ) Traceback (most recent call last): ... _primitives.exceptions.PrimitiveError : Called with more arguments than expected \u2014 \u2b50 \u2014 The primitives library is part of the SOLID python family.","title":"Callable"},{"location":"callable/#callable","text":"Callable fake object is an easy way to reproduce behavior of a function or a method. An empty Callable object will just return null value. >>> from primitives import Callable >>> func = Callable () >>> func () A return value passed to Callable constructor will be returned as is when you'll call the object. >>> func = Callable ( 1 ) >>> func () 1 Only one return value could be passed to the Callable object at the initialization. >>> Callable ( 1 , 2 ) Traceback (most recent call last): ... _primitives.exceptions.PrimitiveError : 'Callable' object should have only one return value To make your fake object be able to accept positional arguments, you can pass Argument object at the initialization. An Argument object should have allowed value for this argument to call. >>> from primitives import Argument >>> func = Callable ( 1 , Argument ( 'a' )) >>> func ( 'a' ) 1 >>> func ( 'b' ) Traceback (most recent call last): ... _primitives.exceptions.PrimitiveError : Called with argument 'b' while expected 'a' If you want your callable fake object to receive arguments but return null, you can avoid specifying return value explicitly. >>> func = Callable ( Argument ( 'a' ), Argument ( 'b' )) >>> func ( 'a' , 'b' ) A Callable fake object would as well check if amount of passed arguments matched arity of declared function. >>> func ( 'a' ) Traceback (most recent call last): ... _primitives.exceptions.PrimitiveError : Called with less arguments than expected >>> func ( 'a' , 'b' , 'c' ) Traceback (most recent call last): ... _primitives.exceptions.PrimitiveError : Called with more arguments than expected \u2014 \u2b50 \u2014 The primitives library is part of the SOLID python family.","title":"Callable"},{"location":"changelog/","text":"1.6.0 (2021-08-24) \u00b6 Features \u00b6 async context object value #60 2ac4c39 1.5.0 (2021-08-24) \u00b6 Features \u00b6 empty async context object #59 a1cf18b 1.4.0 (2021-08-22) \u00b6 Features \u00b6 implement instance object #6 84c2a07 1.3.0 (2021-08-21) \u00b6 Features \u00b6 implement awaitable object #53 ec19656 1.2.0 (2021-01-03) \u00b6 Features \u00b6 implement callable positional argument #4 1.1.0 (2021-01-02) \u00b6 Features \u00b6 implement callable return value #3 1.0.0 (2020-12-26) \u00b6 Features \u00b6 empty Callable object #2 \u2014 \u2b50 \u2014 The primitives library is part of the SOLID python family.","title":"Changelog"},{"location":"changelog/#160-2021-08-24","text":"","title":"1.6.0 (2021-08-24)"},{"location":"changelog/#features","text":"async context object value #60 2ac4c39","title":"Features"},{"location":"changelog/#150-2021-08-24","text":"","title":"1.5.0 (2021-08-24)"},{"location":"changelog/#features_1","text":"empty async context object #59 a1cf18b","title":"Features"},{"location":"changelog/#140-2021-08-22","text":"","title":"1.4.0 (2021-08-22)"},{"location":"changelog/#features_2","text":"implement instance object #6 84c2a07","title":"Features"},{"location":"changelog/#130-2021-08-21","text":"","title":"1.3.0 (2021-08-21)"},{"location":"changelog/#features_3","text":"implement awaitable object #53 ec19656","title":"Features"},{"location":"changelog/#120-2021-01-03","text":"","title":"1.2.0 (2021-01-03)"},{"location":"changelog/#features_4","text":"implement callable positional argument #4","title":"Features"},{"location":"changelog/#110-2021-01-02","text":"","title":"1.1.0 (2021-01-02)"},{"location":"changelog/#features_5","text":"implement callable return value #3","title":"Features"},{"location":"changelog/#100-2020-12-26","text":"","title":"1.0.0 (2020-12-26)"},{"location":"changelog/#features_6","text":"empty Callable object #2 \u2014 \u2b50 \u2014 The primitives library is part of the SOLID python family.","title":"Features"},{"location":"installation/","text":"Installation \u00b6 The primitives library is available on PyPI. To install it run: pip install -U primitives We use semantic release to publish packages as soon as pull requests land to the release branch. It's not necessary to use develompment version of the library. We officially support three last minor releases of CPython interpreter and last minor release of PyPy interpreter. We highly recommend the latest patch release of each Python series. \u2014 \u2b50 \u2014 The primitives library is part of the SOLID python family.","title":"Installation"},{"location":"installation/#installation","text":"The primitives library is available on PyPI. To install it run: pip install -U primitives We use semantic release to publish packages as soon as pull requests land to the release branch. It's not necessary to use develompment version of the library. We officially support three last minor releases of CPython interpreter and last minor release of PyPy interpreter. We highly recommend the latest patch release of each Python series. \u2014 \u2b50 \u2014 The primitives library is part of the SOLID python family.","title":"Installation"},{"location":"instance/","text":"Instance \u00b6 Principles \u00b6 Empty Instance object does not have attributes Instance object provide attribute access to methods Instance object provide attribute access to async methods Empty Instance object does not have attributes \u00b6 >>> from primitives import Instance , Callable , Argument , Awaitable >>> user = Instance () >>> hasattr ( user , \"greet\" ) False Instance object provide attribute access to methods \u00b6 >>> user = Instance ( greet = Callable ( 'Hello, John' , Argument ( 'John' ))) >>> user . greet ( 'John' ) 'Hello, John' Instance object provide attribute access to async methods \u00b6 >>> import asyncio >>> user = Instance ( greet = Callable ( Awaitable ( 'Hello, John' ), Argument ( 'John' ))) >>> async def check (): ... return await user . greet ( 'John' ) >>> asyncio . run ( check ()) 'Hello, John' \u2014 \u2b50 \u2014 The primitives library is part of the SOLID python family.","title":"Instance"},{"location":"instance/#instance","text":"","title":"Instance"},{"location":"instance/#principles","text":"Empty Instance object does not have attributes Instance object provide attribute access to methods Instance object provide attribute access to async methods","title":"Principles"},{"location":"instance/#empty-instance-object-does-not-have-attributes","text":">>> from primitives import Instance , Callable , Argument , Awaitable >>> user = Instance () >>> hasattr ( user , \"greet\" ) False","title":"Empty Instance object does not have attributes"},{"location":"instance/#instance-object-provide-attribute-access-to-methods","text":">>> user = Instance ( greet = Callable ( 'Hello, John' , Argument ( 'John' ))) >>> user . greet ( 'John' ) 'Hello, John'","title":"Instance object provide attribute access to methods"},{"location":"instance/#instance-object-provide-attribute-access-to-async-methods","text":">>> import asyncio >>> user = Instance ( greet = Callable ( Awaitable ( 'Hello, John' ), Argument ( 'John' ))) >>> async def check (): ... return await user . greet ( 'John' ) >>> asyncio . run ( check ()) 'Hello, John' \u2014 \u2b50 \u2014 The primitives library is part of the SOLID python family.","title":"Instance object provide attribute access to async methods"}]}